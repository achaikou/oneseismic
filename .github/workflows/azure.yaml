name: CI-Azure

on:
  workflow_dispatch:
  #schedule:
    # Run at 15.52 UTC every day
  #  - cron: '52 15 * * *'

jobs:
  before_performance_tests:
    name: Before All Performance tests on Azure
    runs-on: ubuntu-latest
    environment: Test

    env:
      ENVIRONMENT: test
    steps:
      - uses: actions/checkout@v2

      - name: Set infrastructure parameters
        run: |
          echo "CONTAINER_REGISTRY=${{ secrets.SETUP_PREFIX }}0containerRegistry.azurecr.io" >> $GITHUB_ENV

      - name: Login to Docker Registry with Service Principal
        uses: docker/login-action@v1
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Build and push performance image to Docker
        run: |
          tag=${{ env.CONTAINER_REGISTRY }}/playground/performance
          docker build -f tests/performance/Dockerfile -t $tag .
          docker push $tag

  performance_tests:
    # Note: job uses default resources. Setup from the main resource is used
    #
    # Service Principal should have access to Resource group and "push" privileges to the container registry
    #
    # The following secrets are required:
    # SETUP_PREFIX: prefix for all created resources
    # RESOURCE_GROUP : name of the resource group used for deployment
    # AZURE_CLIENT_ID : client (application) id of the Service principal
    # AZURE_CLIENT_SECRET : client secret of the Service Principal
    # AZURE_CREDENTIALS : {"clientId": "<>","clientSecret": "<>","subscriptionId": "<>","tenantId": "<>"}
    # STORAGE_ACCOUNT_KEY : key used to access storage
    # SIGN_KEY : string used for secure exchange of information between services
    name: Performance tests on Azure
    runs-on: ubuntu-latest
    environment: Test
    needs: [before_performance_tests]

    env:
      ENVIRONMENT: test
    strategy:
      max-parallel: 1
      matrix:
        include:
          - ilines: 4000
            xlines: 300
            samples: 1500
            duration: "1m"
            vus: 1
          # - ilines: 4000
          #   xlines: 3000
          #   samples: 1500
          #   duration: "10m"
          #   vus: 5

    steps:
      - uses: actions/checkout@v2
      - name: Login to Azure with Service Principal
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set infrastructure parameters
        run: |
          echo "CONTAINER_REGISTRY=${{ secrets.SETUP_PREFIX }}0containerRegistry.azurecr.io" >> $GITHUB_ENV
          echo "CREATE_CONTAINER_INSTANCE=${{ secrets.SETUP_PREFIX }}-create-file-job" >> $GITHUB_ENV
          echo "UPLOAD_CONTAINER_INSTANCE=${{ secrets.SETUP_PREFIX }}-upload-file-job" >> $GITHUB_ENV
          echo "CLEANUP_CONTAINER_INSTANCE=${{ secrets.SETUP_PREFIX }}-cleanup-container-job" >> $GITHUB_ENV
          echo "STORAGE_URL=https://${{ secrets.SETUP_PREFIX }}0storage.blob.core.windows.net" >> $GITHUB_ENV
          echo "RANDOM_VALUE"=$RANDOM >> $GITHUB_ENV
          echo "FILENAME=${{ matrix.ilines }}-x-${{ matrix.xlines }}-x-${{ matrix.samples }}.segy" >> $GITHUB_ENV

        # CI doesn't have enough space for large files. So create and upload them with Azure
      - name: Create segy file
        uses: azure/arm-deploy@v1
        with:
          deploymentName: performanceTests-createFile
          resourceGroupName: ${{ secrets.RESOURCE_GROUP }}
          template: tests/performance/create.bicep
          parameters: setupPrefix=${{ secrets.SETUP_PREFIX }} random=${{ env.RANDOM_VALUE }} fileName=${{ env.FILENAME }} ilinesNumber=${{ matrix.ilines }} xlinesNumber=${{ matrix.xlines }} samplesNumber=${{ matrix.samples }}

      - name: Wait until file is created
        timeout-minutes: 60
        uses: './.github/actions/wait_for_container_termination'
        with:
          container_instance_name: ${{ env.CREATE_CONTAINER_INSTANCE }}
          resource_group: ${{ secrets.RESOURCE_GROUP }}

      - name: Print create logs
        if: always()
        run: |
          az container logs --resource-group ${{ secrets.RESOURCE_GROUP }} --name ${{ env.CREATE_CONTAINER_INSTANCE }}

      - name: Upload file
        uses: azure/arm-deploy@v1
        with:
          deploymentName: performanceTests-uploadFile
          resourceGroupName: ${{ secrets.RESOURCE_GROUP }}
          template: tests/performance/upload.bicep
          parameters: setupPrefix=${{ secrets.SETUP_PREFIX }} random=${{ env.RANDOM_VALUE }} fileName=${{ env.FILENAME }}

      - name: Wait until file is uploaded
        timeout-minutes: 60
        uses: './.github/actions/wait_for_container_termination'
        with:
          container_instance_name: ${{ env.UPLOAD_CONTAINER_INSTANCE }}
          resource_group: ${{ secrets.RESOURCE_GROUP }}

# do something here - if guid is not guid, too much stuff fails.
      - name: Print upload logs
        if: always()
        run: |
          # problem: if something is wrong, this will print sas token. Token still might be valid. So maybe logs shouldn't be printed?
          output=$(az container logs --resource-group ${{ secrets.RESOURCE_GROUP }} --name ${{ env.UPLOAD_CONTAINER_INSTANCE }} )
          echo $output
          if [[ $output = *" "* ]]; then
            echo "CI: Unexpected upload output. Expected just GUID"
            exit 1
          fi
          echo "GUID=$output" >> $GITHUB_ENV

      - name: Set server URL
        run: |
          serverURL=$(az deployment group show \
            -g ${{ secrets.RESOURCE_GROUP }} \
            -n performanceTests-setup \
            --query properties.outputs.serverURL.value \
            -o tsv
          )
          echo "SERVER_URL=$serverURL" >> $GITHUB_ENV

      - name: Run performance tests
        env:
          SERVER_URL: ${{ env.SERVER_URL }}
          STORAGE_LOCATION: ${{ env.STORAGE_URL }}
          GUID: ${{ env.GUID }}
          AZURE_STORAGE_ACCOUNT_KEY: ${{ secrets.STORAGE_ACCOUNT_KEY }}
        run: |
          tag=performance
          echo "TEST_IMAGE_TAG=$tag" >> $GITHUB_ENV
          docker build -f tests/performance/Dockerfile -t $tag .
          docker run \
            -e AZURE_STORAGE_ACCOUNT_KEY \
            -e STORAGE_LOCATION \
            -e SERVER_URL \
            -e GUID \
            -v $(pwd)/out:/out \
            $tag \
            /bin/sh -c 'python ./tests/performance/performance.py ${{ matrix.vus }} ${{ matrix.duration }}'

      - name: Print stderr
        if: always()
        run: |
          cat out/stderr.txt

      - name: Print stdout
        if: always()
        run: |
          cat out/stdout.txt

      - name: Print summary
        if: always()
        run: |
          cat out/summary.json

      # # these two always as well. And continue on failure
      - name: Cleanup created files
        if: always()
        uses: azure/arm-deploy@v1
        with:
          deploymentName: performanceTests-teardown
          resourceGroupName: ${{ secrets.RESOURCE_GROUP }}
          template: tests/performance/teardown.bicep
          parameters: setupPrefix=${{ secrets.SETUP_PREFIX }} random=${{ env.RANDOM_VALUE }} fileName=${{ env.FILENAME }} guid=${{ env.GUID }}

      - name: Wait until data is deleted
        timeout-minutes: 10
        uses: './.github/actions/wait_for_container_termination'
        with:
          container_instance_name: ${{ env.CLEANUP_CONTAINER_INSTANCE }}
          resource_group: ${{ secrets.RESOURCE_GROUP }}

      - name: Print container cleanup logs
        if: always()
        run: |
          az container logs --resource-group ${{ secrets.RESOURCE_GROUP }} --name ${{ env.CLEANUP_CONTAINER_INSTANCE }}
