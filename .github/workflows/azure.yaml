name: CI-Azure

on:
  workflow_dispatch:
  schedule:
    # Run at 15.52 UTC every day
    - cron: '52 15 * * *'

jobs:
  azure_tests:
    # Note: as job uses just one set of resources, so concurrent PRs and merges might cause trouble
    # due to currently low number of PRs this is acceptable for now
    #
    # Service Principal should have access to Resource group and "push" privileges to the container registry
    #
    # The following secrets are required:
    # SETUP_PREFIX: prefix for all created resources
    # RESOURCE_GROUP : name of the resource group used for deployment
    # AZURE_CLIENT_ID : client (application) id of the Service principal
    # AZURE_CLIENT_SECRET : client secret of the Service Principal
    # AZURE_CREDENTIALS : {"clientId": "<>","clientSecret": "<>","subscriptionId": "<>","tenantId": "<>"}
    # STORAGE_ACCOUNT_KEY : key used to access storage
    # SIGN_KEY : string used for secure exchange of information between services
    name: Integration tests on Azure
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - desc: Azure tests with python client
            dockerfile: tests/python/Dockerfile
    environment: Test
    env:
      ENVIRONMENT: test
      REVISION_ID: ${{ github.sha }} # or "latest"
      DEPLOYMENT_NAME: ${{ github.sha }}
    steps:
      - uses: actions/checkout@v2

      - name: Set missing docker parameters
        run: |
          echo "CONTAINER_REGISTRY=${{ secrets.SETUP_PREFIX }}0containerRegistry.azurecr.io" >> $GITHUB_ENV

      - name: Login to Docker Registry with Service Principal
        uses: docker/login-action@v1
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Build and push server code with Docker if image doesn't exist
        run: |
          image=${{ env.CONTAINER_REGISTRY }}/apps/oneseismic:$REVISION_ID
          if ! docker manifest inspect $image > /dev/null ; then
            docker build -t $image .
            docker push $image
          fi

      - name: Login to Azure with Service Principal
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Activate revision if it already exists
        run: |
          fetch_app_name=${{ secrets.SETUP_PREFIX }}-fetch
          nginx_app_name=${{ secrets.SETUP_PREFIX }}-nginx
          fetch_revision=$fetch_app_name--${{ env.REVISION_ID }}
          nginx_revision=$nginx_app_name--${{ env.REVISION_ID }}
          fetch_exists=false
          nginx_exists=false

          az extension add --name containerapp

          if az containerapp revision activate -n $fetch_app_name -g ${{ secrets.RESOURCE_GROUP }} --revision $fetch_revision > /dev/null ; then
            echo "Fetch revision exists and is activated"
            fetch_exists=true
          fi

          if az containerapp revision activate -n $nginx_app_name -g ${{ secrets.RESOURCE_GROUP }} --revision $nginx_revision > /dev/null ; then
            echo "Nginx revision exists and is activated"
            az containerapp ingress traffic set -n $nginx_app_name -g ${{ secrets.RESOURCE_GROUP }} --revision-weight $nginx_revision=100
            nginx_exists=true
          fi

          if [[ $fetch_exists != $nginx_exists ]] ; then
            echo "Unexpected situation: fetch and nginx apps have different status"
            (exit 1)
          fi

          echo "REVISION_ALREADY_EXISTS=$fetch_exists" >> $GITHUB_ENV

      - name: Deploy server code if not already deployed
        if: ${{ env.REVISION_ALREADY_EXISTS == 'false' }}
        uses: azure/arm-deploy@v1
        with:
          deploymentName: ${{ env.DEPLOYMENT_NAME }}
          resourceGroupName: ${{ secrets.RESOURCE_GROUP }}
          template: deploy/main.bicep
          parameters: environment=${{ env.ENVIRONMENT }} setupPrefix=${{ secrets.SETUP_PREFIX }} revisionId=${{ env.REVISION_ID }} signKey=${{ secrets.SIGN_KEY }}

      - name: Set missing test parameters
        run: |
          serverURL=$(az deployment group show \
            -g ${{ secrets.RESOURCE_GROUP }} \
            -n ${{ env.DEPLOYMENT_NAME }} \
            --query properties.outputs.serverURL.value \
            -o tsv
          )
          if [[ -z $serverURL ]] ; then
            echo "Server URL is not found in deployment"
            (exit 1)
          fi
          echo "SERVER_URL=$serverURL" >> $GITHUB_ENV
          echo "STORAGE_URL=https://${{ secrets.SETUP_PREFIX }}0storage.blob.core.windows.net" >> $GITHUB_ENV

      - name: Run azure tests
        env:
          SERVER_URL: ${{ env.SERVER_URL }}
          STORAGE_LOCATION: ${{ env.STORAGE_URL }}
          AZURE_STORAGE_ACCOUNT_KEY: ${{ secrets.STORAGE_ACCOUNT_KEY }}
        run: |
          tag=local/test/oneseismic
          docker build -f ${{ matrix.dockerfile }} --target cloudtest -t $tag .
          docker run \
            -e AZURE_STORAGE_ACCOUNT_KEY \
            -e STORAGE_LOCATION \
            -e SERVER_URL \
            $tag

  notify:
    name: Report on failure
    needs: [azure_tests]
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'schedule'
    steps:
    - name: Send GitHub Action trigger data to Slack workflow
      id: slack
      uses: slackapi/slack-github-action@v1.18.0
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_AZURE_WEBHOOK_URL }}
